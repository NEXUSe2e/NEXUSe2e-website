import{N as i}from"./NEXUSe2eImage-DCB7g-Zi.js";import{m as e}from"./marked.esm-8ZxQ78w7.js";import{d as c,c as l,w as t,V as u,o as h,a as o,b as r,u as n,e as d}from"./index-R_OBdHHJ.js";const p="/assets/routes-BjgQbrei.png",f=["innerHTML"],m=["innerHTML"],T=c({__name:"index",setup(y){const s=e(`
# Routes
---
While the old TRP concept was quite versatile, it was also quite clunky and not easy to understand. The routes are part of the replacement concept for them. A route describes a link between two partners.
`),a=e(`
Which partner is used as first or second is not relevant for the behavior (#1 and #2). We strongly suggest having a pattern for your self, but technically there is no difference. Therefore its also possible to reference two external or two internal partners in one route. To do so, you have to activate the "allow same Partner Type" checkbox which acts as a safety net for your configuration. As routes are only the building block to all connectivity options, you always need to create the partners first. The selected partner (#3) must have a valid connection (#4). You can optionally configure a client certificate (#5) for this partner and connection. This is used to identify yourself against the server configured in the connection. Last but not least you can configure an Inflow pipeline for this route which is triggered after an inflow messages is processed by the resolver pipeline (#6). This is required because the resolver pipeline extracts the routing parameters like choreography and partner which are used to determine the route. The message is stored the first time after the optional Inflow Pipeline is processed successfully.
`);return(g,w)=>(h(),l(u,null,{default:t(()=>[o(d,{cols:"12"},{default:t(()=>[r("div",{innerHTML:n(s)},null,8,f),o(i,{src:p}),r("div",{innerHTML:n(a)},null,8,m)]),_:1})]),_:1}))}});export{T as default};
